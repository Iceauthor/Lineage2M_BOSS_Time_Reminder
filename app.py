from apscheduler.schedulers.background import BackgroundScheduler
import os
import json
import psycopg2
from flask import Flask, request, abort
from dotenv import load_dotenv
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import MessageEvent, TextMessage, TextSendMessage, FlexSendMessage
from datetime import datetime, timedelta
import pytz


load_dotenv()
app = Flask(__name__)
line_bot_api = LineBotApi(os.getenv("LINE_CHANNEL_ACCESS_TOKEN"))
handler = WebhookHandler(os.getenv("LINE_CHANNEL_SECRET"))

def get_db_connection():
    return psycopg2.connect(
        host=os.getenv("DB_HOST"),
        port=os.getenv("DB_PORT"),
        user=os.getenv("DB_USER"),
        password=os.getenv("DB_PASSWORD"),
        dbname=os.getenv("DB_NAME")
    )

def get_respawn_hours_by_name(name):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT respawn_hours FROM boss_list WHERE display_name = %s", (name,))
    result = cursor.fetchone()
    cursor.close()
    conn.close()
    return result[0] if result else None


# Ëá™ÂãïÊ∏ÖÁêÜÈáçË§á boss_aliases ‰∏¶Âª∫Á´ãÂîØ‰∏ÄÁ¥¢Âºï
def cleanup_boss_aliases():
    try:
        def cleanup_boss_aliases():
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                DELETE FROM boss_aliases a
                USING boss_aliases b
                WHERE a.id < b.id
                  AND a.boss_id = b.boss_id
                  AND a.keyword = b.keyword
            """)
            cursor.execute("""
                DO $$
                BEGIN
                    IF NOT EXISTS (
                        SELECT 1 FROM pg_indexes WHERE indexname = 'unique_boss_keyword'
                    ) THEN
                        CREATE UNIQUE INDEX unique_boss_keyword ON boss_aliases(boss_id, keyword);
                    END IF;
                END$$;
            """)
            conn.commit()
            cursor.close()
            conn.close()
            print("‚úÖ Â∑≤Ê∏ÖÈô§ÈáçË§á boss_aliases\n‚úÖ Â∑≤Âª∫Á´ãÂîØ‰∏ÄÁ¥¢Âºï")

    except Exception as e:
        print("‚ùå Ê∏ÖÁêÜ/Á¥¢ÂºïÂª∫Á´ãÂ§±ÊïóÔºö", e)


# Ëá™ÂãïÂåØÂÖ• boss_list.json Ë≥áÊñô
def auto_insert_boss_list():
    print("üöÄ Âü∑Ë°å BOSS Ëá™ÂãïÂåØÂÖ•")
    conn = get_db_connection()
    cursor = conn.cursor()

    with open("boss_list.json", "r", encoding="utf-8") as f:
        bosses = json.load(f)

    # Ê∏ÖÁ©∫ËàäÊúâË≥áÊñô
    cursor.execute("DELETE FROM boss_aliases")
    print("‚úÖ Â∑≤Ê∏ÖÈô§ boss_aliases Ë≥áÊñô")

    for boss in bosses:
        display_name = boss["display_name"]
        respawn_hours = boss["respawn_hours"]
        keywords = boss["keywords"]

        # Êñ∞Â¢û boss ‰∏ªË≥áÊñô
        cursor.execute("""
            INSERT INTO boss_list (display_name, respawn_hours)
            VALUES (%s, %s)
            ON CONFLICT (display_name)
            DO UPDATE SET respawn_hours = EXCLUDED.respawn_hours
            RETURNING id
        """, (display_name, respawn_hours))
        boss_id = cursor.fetchone()[0]

        # Êñ∞Â¢ûÂ∞çÊáâ keyword
        for keyword in keywords:
            cursor.execute("""
                INSERT INTO boss_aliases (boss_id, keyword)
                VALUES (%s, %s)
                ON CONFLICT DO NOTHING
            """, (boss_id, keyword.lower()))

    conn.commit()
    cursor.close()
    conn.close()
    print("‚úÖ BOSS Ë≥áÊñôÂåØÂÖ•ÂÆåÊàê")



# ÂïüÂãïÊôÇÂÖàÂü∑Ë°å‰∏ÄÊ¨°Ê∏ÖÁêÜ + ÂåØÂÖ•
cleanup_boss_aliases()
auto_insert_boss_list()


@app.route("/", methods=["GET"])
def home():
    return "‚úÖ Lineage2M BOSS Reminder Bot is running."

@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)
    return 'OK'


@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    text = event.message.text.strip()
    group_id = event.source.group_id if event.source.type == "group" else "single"
    
    # ËôïÁêÜ K ÂÖã4 170124ÔºàÁï∂Êó•ÊåáÂÆöÊôÇÈñìÔºâ
    if text.lower().startswith("k "):
        parts = text.split()
        if len(parts) == 3 and parts[2].isdigit() and len(parts[2]) == 6:
            _, keyword, timestr = parts
            try:
                hour = int(timestr[0:2])
                minute = int(timestr[2:4])
                second = int(timestr[4:6])
                tz = pytz.timezone("Asia/Taipei")
                kill_time = datetime.now(tz).replace(hour=hour, minute=minute, second=second, microsecond=0)

                conn = get_db_connection()
                cursor = conn.cursor()
                keyword = keyword.lower()
                cursor.execute("""
                    SELECT b.id, b.display_name, b.respawn_hours
                    FROM boss_aliases a
                    JOIN boss_list b ON a.boss_id = b.id
                    WHERE a.keyword = %s
                """, (keyword,))
                row = cursor.fetchone()
                if row:
                    boss_id, display_name, respawn_hours = row
                    respawn_time = kill_time + timedelta(hours=respawn_hours)
                    cursor.execute(
                        "INSERT INTO boss_tasks (boss_id, group_id, kill_time, respawn_time) VALUES (%s, %s, %s, %s)",
                        (boss_id, group_id, kill_time, respawn_time)
                    )
                    conn.commit()
                    reply_text = f"\n\nüî¥ ÊìäÊÆ∫Ôºö{display_name}\nüïì Ê≠ª‰∫°Ôºö{kill_time.strftime('%Y-%m-%d %H:%M:%S')}\nüü¢ ÈáçÁîüÔºö{respawn_time.strftime('%Y-%m-%d %H:%M:%S')}"
                else:
                    reply_text = "‚ùå Êâæ‰∏çÂà∞Ë©≤ BOSS ÈóúÈçµÂ≠ó„ÄÇ"
                cursor.close()
                conn.close()
            except:
                reply_text = "‚ùå ÊôÇÈñìÊ†ºÂºèÈåØË™§ÔºåË´ã‰ΩøÁî® K ÂÖã4 170124 ÁöÑÊ†ºÂºè„ÄÇ"
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text))
            return

    # ËôïÁêÜ clear all Êåá‰ª§ÔºöÊ∏ÖÈô§Ë©≤Áæ§ÁµÑÊâÄÊúâ BOSS Á¥ÄÈåÑ
    if text.lower().strip() == "clear all":
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM boss_tasks WHERE group_id = %s", (group_id,))
        conn.commit()
        cursor.close()
        conn.close()
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text="‚úÖ Â∑≤Ê∏ÖÈô§Êú¨Áæ§ÁµÑÊâÄÊúâ BOSS Á¥ÄÈåÑ"))
        return

    # ËôïÁêÜ kr1„ÄÅkr2 ÂÖã4 170124 Ê†ºÂºèÔºåÊåáÂÆöÂâçÊó•ÊàñÂâçÂÖ©Êó•Ê≠ª‰∫°ÊôÇÈñì
    if text.lower().startswith("kr1 ") or text.lower().startswith("kr2 "):
        parts = text.split()
        if len(parts) == 3:
            prefix, keyword, timestr = parts
            try:
                hour = int(timestr[0:2])
                minute = int(timestr[2:4])
                second = int(timestr[4:6])
                offset_days = 1 if prefix.lower() == "kr1" else 2
                kill_time = datetime.now(pytz.timezone("Asia/Taipei")) - timedelta(days=offset_days)
                kill_time = kill_time.replace(hour=hour, minute=minute, second=second, microsecond=0)

                conn = get_db_connection()
                cursor = conn.cursor()
                keyword = keyword.lower()
                cursor.execute("""
                    SELECT b.id, b.display_name, b.respawn_hours
                    FROM boss_aliases a
                    JOIN boss_list b ON a.boss_id = b.id
                    WHERE a.keyword = %s
                """, (keyword,))
                row = cursor.fetchone()
                if row:
                    boss_id, display_name, respawn_hours = row
                    respawn_time = kill_time + timedelta(hours=respawn_hours)
                    cursor.execute(
                        "INSERT INTO boss_tasks (boss_id, group_id, kill_time, respawn_time) VALUES (%s, %s, %s, %s)",
                        (boss_id, group_id, kill_time, respawn_time)
                    )
                    conn.commit()
                    reply_text = f"\n\nüî¥ ÊìäÊÆ∫Ôºö{display_name}\nüïì Ê≠ª‰∫°Ôºö{kill_time.strftime('%Y-%m-%d %H:%M:%S')}\nüü¢ ÈáçÁîüÔºö{respawn_time.strftime('%Y-%m-%d %H:%M:%S')}"
                else:
                    reply_text = "‚ùå Êâæ‰∏çÂà∞Ë©≤ BOSS ÈóúÈçµÂ≠ó„ÄÇ"
                cursor.close()
                conn.close()
            except:
                reply_text = "‚ùå ÊôÇÈñìÊ†ºÂºèÈåØË™§ÔºåË´ã‰ΩøÁî® kr1 ÂÖã4 170124 ÁöÑÊ†ºÂºè„ÄÇ"
        else:
            reply_text = "‚ùå Êåá‰ª§Ê†ºÂºèÈåØË™§ÔºåË´ã‰ΩøÁî® kr1 ÂÖã4 170124 ÁöÑÊ†ºÂºè„ÄÇ"
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text))
        return
    # ËôïÁêÜ K„ÄÅk Êåá‰ª§‰ΩúÁÇ∫ÊìäÊÆ∫Á¥ÄÈåÑ
    if text.lower().startswith("k "):
        keyword = text[2:].strip()
        conn = get_db_connection()
        cursor = conn.cursor()
        keyword = keyword.lower()
        cursor.execute("""
            SELECT b.id, b.display_name, b.respawn_hours
            FROM boss_aliases a
            JOIN boss_list b ON a.boss_id = b.id
            WHERE a.keyword = %s
        """, (keyword,))
        row = cursor.fetchone()
        if row:
            boss_id, display_name, respawn_hours = row
            now = datetime.now(pytz.timezone('Asia/Taipei'))
            respawn_time = now + timedelta(hours=respawn_hours)

            # ÂÖàÂà™Èô§Âêå‰∏ÄÁæ§ÁµÑÂêå‰∏Ä BOSS ÁöÑËàäË≥áÊñô
            cursor.execute("DELETE FROM boss_tasks WHERE boss_id = %s AND group_id = %s", (boss_id, group_id))

            # ÊèíÂÖ•Êñ∞Á¥ÄÈåÑ
            cursor.execute(
                "INSERT INTO boss_tasks (boss_id, group_id, kill_time, respawn_time) VALUES (%s, %s, %s, %s)",
                (boss_id, group_id, now, respawn_time)
            )
            conn.commit()

            reply_text = f"\n\nüî¥ ÊìäÊÆ∫Ôºö{display_name}\nüïì Ê≠ª‰∫°Ôºö{now.strftime('%Y-%m-%d %H:%M:%S')}\nüü¢ ÈáçÁîüÔºö{respawn_time.strftime('%Y-%m-%d %H:%M:%S')}"
        else:
            reply_text = "‚ùå ÁÑ°Ê≥ïËæ®Ë≠òÁöÑÈóúÈçµÂ≠óÔºåË´ãÂÖà‰ΩøÁî® add Êåá‰ª§Êñ∞Â¢û„ÄÇ"
        cursor.close()
        conn.close()
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text))
        return

    text = event.message.text.strip().lower()
    group_id = event.source.group_id if event.source.type == "group" else "single"
    if text in ["kb all", "Âá∫"]:
        conn = get_db_connection()
        cursor = conn.cursor()

        cursor.execute("""
            SELECT
                b.display_name,
                t.id,  -- boss_tasks id
                t.kill_time,
                b.respawn_hours
            FROM boss_list b
            LEFT JOIN LATERAL (
                SELECT id, kill_time
                FROM boss_tasks
                WHERE boss_id = b.id AND group_id = %s
                ORDER BY kill_time DESC, id DESC
                LIMIT 1
            ) t ON true
            ORDER BY 
              CASE WHEN t.kill_time IS NULL THEN 1 ELSE 0 END,
              (t.kill_time + (b.respawn_hours || ' hours')::interval)
        """, (group_id,))
        results = cursor.fetchall()
        cursor.close()
        conn.close()

        tz = pytz.timezone('Asia/Taipei')
        now = datetime.now(tz)
        soon = now + timedelta(minutes=30)
        next_24hr = now + timedelta(hours=24)

        lines = ["üïì Âç≥Â∞áÈáçÁîü BOSSÔºö\n"]

        yellow_list = [
            "Ë¢´Ê±ôÊüìÁöÑÂÖãÈ≠ØÁë™", "Âè∏Á©ÜËâæÁàæ", "ÊèêÁ±≥ÁâπÂà©ÊñØ", "Á™ÅËÆäÂÖãÈ≠ØÁë™", "ÈªëËâ≤ËïæÁàæËéâ",
            "ÂØáÂÄ´", "ÊèêÁ±≥Â¶ÆÁàæ", "Âç°Âù¶", "Ëò≠Â§öÂãí", "Ë≤ùÂ∏åËé´ÊñØ", "Ëñ©Áè≠", "Âè≤Âù¶",
            "ÂøòÂçª‰πãÈè°", "Â§ßÂú∞Á•≠Â£á", "Ê∞¥‰πãÁ•≠Â£á", "È¢®‰πãÁ•≠Â£á", "ÈªëÈóáÁ•≠Â£á", "ÂÖãÊãâÂ•á",
            "Ê¢ÖÊùúËéé", "Ê≤ôÂãíÂç°", "Â°îÊãâÈáë"
        ]

        purple_list = [
            "ÈªëÂç°È†ì", "Â°îÈÇ£ÈÄèÊñØ", "Â∑¥ÂÄ´", "Êë©Âæ∑ÁÉèÊñØ", "Ê≠êÂÖãÊñØ", "Ëñ©ÊãâÂÖãÊñØ", "ÂìàÊôÆ", "Èú∏ÊãâÂÖã",
            "ÂÆâÂæ∑ÊãâÊñØ", "Á¥ç‰ºäÈòøÊñØ", "Ê†∏ÂøÉÂü∫Â∫ß", "Â∑®ËüªÂ•≥Áéã", "Âç°Â∏ÉÈáåÊ≠ê", "È≥≥Âá∞", "ÁåõÈæçÁç∏",
            "Â•ßÁàæËä¨", "ÂºóÊûóÁâπ", "Êãâ‰Ωï"
        ]

        flex_contents = []

        sorted_results = sorted(results, key=lambda r: (r[2] + timedelta(hours=r[3])) if r[2] else datetime.max)
        for name, task_id, kill_time, hours in sorted_results:

            box = {
                "type": "box",
                "layout": "vertical",
                "paddingAll": "md",
                "margin": "sm",
                "contents": [],
            }

            # Âà§Êñ∑ÊúâÁÑ°Á¥ÄÈåÑ
            if kill_time:
                respawn_time = kill_time.astimezone(tz) + timedelta(hours=hours)
                if now < respawn_time <= soon:
                    color = "#D60000"
                    note = "ÔºàÂø´ÈáçÁîüÔºâ"
                    emoji = "üî• "
                    weight = "bold"
                    text_block = {
                        "type": "text",
                        "text": f"{emoji}{respawn_time.strftime('%H:%M:%S')} {name}{note}",
                        "color": color,
                        "weight": weight,
                        "size": "sm",
                        "wrap": True
                    }
                    box = {
                        "type": "box",
                        "layout": "vertical",
                        "contents": [text_block]
                    }
                    if name in yellow_list:
                        box["backgroundColor"] = "#FFF9DC"  # Ê∑°ÈµùÈªÉËâ≤
                    elif name in purple_list:
                        box["backgroundColor"] = "#F5F0FF"  # Ê∑°Á≤âÁ¥´Ëâ≤
                    flex_contents.append(box)
                elif now > respawn_time:
                    diff = (now - respawn_time).total_seconds()
                    passed = int(diff // (hours * 3600))
                    note = f"ÔºàÈÅé{passed}Ôºâ" if passed >= 1 else ""
                    color = "#999999"
                    emoji = ""
                    weight = "regular"
                    text_block = {
                        "type": "text",
                        "text": f"{emoji}{respawn_time.strftime('%H:%M:%S')} {name}{note}",
                        "color": color,
                        "weight": weight,
                        "size": "sm",
                        "wrap": True
                    }
                    box = {
                        "type": "box",
                        "layout": "vertical",
                        "contents": [text_block]
                    }
                    if name in yellow_list:
                        box["backgroundColor"] = "#FFF9DC"  # Ê∑°ÈµùÈªÉËâ≤
                    elif name in purple_list:
                        box["backgroundColor"] = "#F5F0FF"  # Ê∑°Á≤âÁ¥´Ëâ≤
                    flex_contents.append(box)
                else:
                    color = "#000000"
                    note = ""
                    emoji = ""
                    weight = "regular"
                    text_block = {
                        "type": "text",
                        "text": f"{emoji}{respawn_time.strftime('%H:%M:%S')} {name}{note}",
                        "color": color,
                        "weight": weight,
                        "size": "sm",
                        "wrap": True
                    }
                    box = {
                        "type": "box",
                        "layout": "vertical",
                        "contents": [text_block]
                    }
                    if name in yellow_list:
                        box["backgroundColor"] = "#FFF9DC"  # Ê∑°ÈµùÈªÉËâ≤
                    elif name in purple_list:
                        box["backgroundColor"] = "#F5F0FF"  # Ê∑°Á≤âÁ¥´Ëâ≤
                    flex_contents.append(box)
                time_str = respawn_time.strftime("%H:%M:%S")
            else:
                text_block = {
                    "type": "text",
                    "text": f"__:__:__ {name}",
                    "color": "#CCCCCC",
                    "size": "sm",
                    "wrap": True
                }
                box = {
                    "type": "box",
                    "layout": "vertical",
                    "contents": [text_block]
                }
                flex_contents.append(box)

        bubble = {
            "type": "bubble",
            "body": {
                "type": "box",
                "layout": "vertical",
                "paddingAll": "md",
                "contents": [
                    {
                        "type": "text",
                        "text": "üïì Âç≥Â∞áÈáçÁîü BOSS",
                        "weight": "bold",
                        "size": "md",
                        "margin": "md"
                    },
                    {
                        "type": "separator",
                        "margin": "md"
                    },
                    *flex_contents
                ]
            }
        }
    # if text in ["kb all", "Âá∫"]:
    #     conn = get_db_connection()
    #     cursor = conn.cursor()
    #     cursor.execute("""
    #         SELECT b.display_name, t.kill_time, b.respawn_hours
    #         FROM boss_list b
    #         LEFT JOIN LATERAL (
    #             SELECT kill_time
    #             FROM boss_tasks
    #             WHERE boss_id = b.id AND group_id = 'Cbf6ece7d4ad7dec03f5dec9e7643ffa1' %s
    #             ORDER BY kill_time DESC
    #             LIMIT 1
    #         ) t ON true
    #     """, (group_id,))
    #     results = cursor.fetchall()
    #     # print(f"üìä Êü•Ë©¢ÁµêÊûúÔºö{results}")
    #     cursor.close()
    #     conn.close()
    #
    #     flex_contents = []
    #     yellow_list = [
    #         "Ë¢´Ê±ôÊüìÁöÑÂÖãÈ≠ØÁë™", "Âè∏Á©ÜËâæÁàæ", "ÊèêÁ±≥ÁâπÂà©ÊñØ", "Á™ÅËÆäÂÖãÈ≠ØÁë™", "ÈªëËâ≤ËïæÁàæËéâ",
    #         "ÂØáÂÄ´", "ÊèêÁ±≥Â¶ÆÁàæ", "Âç°Âù¶", "Ëò≠Â§öÂãí", "Ë≤ùÂ∏åËé´ÊñØ", "Ëñ©Áè≠", "Âè≤Âù¶",
    #         "ÂøòÂçª‰πãÈè°", "Â§ßÂú∞Á•≠Â£á", "Ê∞¥‰πãÁ•≠Â£á", "È¢®‰πãÁ•≠Â£á", "ÈªëÈóáÁ•≠Â£á", "ÂÖãÊãâÂ•á",
    #         "Ê¢ÖÊùúËéé", "Ê≤ôÂãíÂç°", "Â°îÊãâÈáë"
    #     ]
    #
    #     purple_list = [
    #         "ÈªëÂç°È†ì", "Â°îÈÇ£ÈÄèÊñØ", "Â∑¥ÂÄ´", "Êë©Âæ∑ÁÉèÊñØ", "Ê≠êÂÖãÊñØ", "Ëñ©ÊãâÂÖãÊñØ", "ÂìàÊôÆ", "Èú∏ÊãâÂÖã",
    #         "ÂÆâÂæ∑ÊãâÊñØ", "Á¥ç‰ºäÈòøÊñØ", "Ê†∏ÂøÉÂü∫Â∫ß", "Â∑®ËüªÂ•≥Áéã", "Âç°Â∏ÉÈáåÊ≠ê", "È≥≥Âá∞", "ÁåõÈæçÁç∏",
    #         "Â•ßÁàæËä¨", "ÂºóÊûóÁâπ", "Êãâ‰Ωï"
    #     ]
    #
    #     now = datetime.now(pytz.timezone('Asia/Taipei'))
    #     soon = now + timedelta(minutes=30)
    #     next_24hr = now + timedelta(hours=24)
    #     lines = ["üïì Âç≥Â∞áÈáçÁîü BOSSÔºö\n"]
    #
    #     for name, kill_time, respawn_hours in results:
    #         if kill_time:
    #             respawn_time = kill_time.replace(tzinfo=pytz.timezone('Asia/Taipei')) + timedelta(hours=respawn_hours)
    #             if now < respawn_time <= soon:
    #                 color = "#D60000"  # Á¥ÖËâ≤
    #                 emoji = "üî• "
    #                 note = "ÔºàÂø´ÈáçÁîüÔºâ"
    #                 weight = "bold"
    #                 text_block = {
    #                     "type": "text",
    #                     "text": f"{emoji}{respawn_time.strftime('%H:%M:%S')} {name}{note}",
    #                     "color": color,
    #                     "weight": weight,
    #                     "size": "sm",
    #                     "wrap": True
    #                 }
    #                 box = {
    #                     "type": "box",
    #                     "layout": "vertical",
    #                     "contents": [text_block]
    #                 }
    #                 if name in yellow_list:
    #                     box["backgroundColor"] = "#FFF9DC"  # Ê∑°ÈµùÈªÉËâ≤
    #                 elif name in purple_list:
    #                     box["backgroundColor"] = "#F5F0FF"  # Ê∑°Á≤âÁ¥´Ëâ≤
    #                 flex_contents.append(box)
    #             elif now > respawn_time:
    #                 if respawn_hours:
    #                     diff = (now - respawn_time).total_seconds()
    #                     passed_cycles = int(diff // (respawn_hours * 3600))
    #                     if passed_cycles >= 1:
    #                         note = f"ÔºàÈÅé{passed_cycles}Ôºâ"
    #                     else:
    #                         note = ""
    #                     color = "#999999"  # ÁÅ∞Ëâ≤
    #                     emoji = ""
    #                     weight = "regular"
    #                     text_block = {
    #                         "type": "text",
    #                         "text": f"{emoji}{respawn_time.strftime('%H:%M:%S')} {name}{note}",
    #                         "color": color,
    #                         "weight": weight,
    #                         "size": "sm",
    #                         "wrap": True
    #                     }
    #                     box = {
    #                         "type": "box",
    #                         "layout": "vertical",
    #                         "contents": [text_block]
    #                     }
    #                     if name in yellow_list:
    #                         box["backgroundColor"] = "#FFF9DC"  # Ê∑°ÈµùÈªÉËâ≤
    #                     elif name in purple_list:
    #                         box["backgroundColor"] = "#F5F0FF"  # Ê∑°Á≤âÁ¥´Ëâ≤
    #                     flex_contents.append(box)
    #                 else:
    #                     color = "#999999"
    #                     emoji = ""
    #                     note = ""
    #                     weight = "regular"
    #                     text_block = {
    #                         "type": "text",
    #                         "text": f"{emoji}{respawn_time.strftime('%H:%M:%S')} {name}{note}",
    #                         "color": color,
    #                         "weight": weight,
    #                         "size": "sm",
    #                         "wrap": True
    #                     }
    #                     box = {
    #                         "type": "box",
    #                         "layout": "vertical",
    #                         "contents": [text_block]
    #                     }
    #                     if name in yellow_list:
    #                         box["backgroundColor"] = "#FFF9DC"  # Ê∑°ÈµùÈªÉËâ≤
    #                     elif name in purple_list:
    #                         box["backgroundColor"] = "#F5F0FF"  # Ê∑°Á≤âÁ¥´Ëâ≤
    #                     flex_contents.append(box)
    #             else:
    #                 color = "#000000"
    #                 emoji = ""
    #                 note = ""
    #                 weight = "regular"
    #                 text_block = {
    #                     "type": "text",
    #                     "text": f"__:__:__ {name}",
    #                     "color": "#CCCCCC",
    #                     "size": "sm",
    #                     "wrap": True
    #                 }
    #                 box = {
    #                     "type": "box",
    #                     "layout": "vertical",
    #                     "contents": [text_block]
    #                 }
    #                 if name in yellow_list:
    #                     box["backgroundColor"] = "#FFF9DC"  # Ê∑°ÈµùÈªÉËâ≤
    #                 elif name in purple_list:
    #                     box["backgroundColor"] = "#F5F0FF"  # Ê∑°Á≤âÁ¥´Ëâ≤
    #                 flex_contents.append(box)
    #         else:
    #             text_block = {
    #                 "type": "text",
    #                 "text": f"__:__:__ {name}",
    #                 "color": "#CCCCCC",
    #                 "size": "sm",
    #                 "wrap": True
    #             }
    #             box = {
    #                 "type": "box",
    #                 "layout": "vertical",
    #                 "contents": [text_block]
    #             }
    #             flex_contents.append(box)
    #
    #     bubble = {
    #         "type": "bubble",
    #         "body": {
    #             "type": "box",
    #             "layout": "vertical",
    #             "contents": [
    #                 {"type": "text", "text": "üïì Âç≥Â∞áÈáçÁîü BOSS", "weight": "bold", "size": "md", "margin": "md"},
    #                 {"type": "separator", "margin": "md"},
    #                 *flex_contents
    #             ]
    #         }
    #     }
        for name, task_id, kill_time, respawn_hours in results:
            if kill_time:
                respawn_time = kill_time.replace(tzinfo=pytz.timezone('Asia/Taipei')) + timedelta(hours=respawn_hours)
                if now <= respawn_time <= next_24hr:
                    lines.append(f"{respawn_time.strftime('%H:%M:%S')} {name}\n")
                elif now > respawn_time:
                    if respawn_hours:
                        diff = (now - respawn_time).total_seconds()
                        passed_cycles = int(diff // (respawn_hours * 3600))  # Âêë‰∏ãÂèñÊï¥ÔºåÈÅøÂÖçË™§Â∑ÆÊèêÂâçÈÄ≤‰Ωç
                        lines.append(f"{respawn_time.strftime('%H:%M:%S')} {name}ÔºàÈÅé{passed_cycles}Ôºâ\n")
                    else:
                        lines.append(f"{respawn_time.strftime('%H:%M:%S')} {name}\n")
                else:
                    lines.append(f"{respawn_time.strftime('%H:%M:%S')} {name}\n")
            else:
                lines.append(f"__:__:__ {name}\n")

        reply_text = ''.join(lines)
        line_bot_api.reply_message(
            event.reply_token,
            messages=[
                FlexSendMessage(alt_text="BOSS ÈáçÁîüÈ†êÊ∏¨Ë°®", contents=bubble)
                # TextSendMessage(text=reply_text)
            ]
        )
    # ‚úÖ ALIAS Êåá‰ª§ÁÆ°ÁêÜÂçÄÊÆµ
    if text.startswith("alias ") or text.startswith("add "):
        parts = text.split()
        if len(parts) < 2:
            line_bot_api.reply_message(event.reply_token,
                                       TextSendMessage(text="‚ö†Ô∏è Ê†ºÂºèÈåØË™§ÔºåË´ã‰ΩøÁî®Ôºöalias Âà•Âêç Ê≠£ÂºèÂêçÁ®±"))
            return

        subcommand = parts[1].lower()

        # alias del keyword
        if subcommand == "del" and len(parts) == 3:
            keyword = parts[2].lower()
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("DELETE FROM boss_aliases WHERE keyword = %s", (keyword,))
            conn.commit()
            cursor.close()
            conn.close()
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=f"üóëÔ∏è Â∑≤Âà™Èô§Âà•Âêç„Äå{keyword}„Äç"))
            return

        # alias check keyword
        if subcommand == "check" and len(parts) == 3:
            keyword = parts[2].lower()
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                SELECT b.display_name FROM boss_aliases a
                JOIN boss_list b ON a.boss_id = b.id
                WHERE a.keyword = %s
            """, (keyword,))
            row = cursor.fetchone()
            cursor.close()
            conn.close()
            if row:
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text=f"üîç „Äå{keyword}„Äç Â∞çÊáâ BOSSÔºö{row[0]}"))
            else:
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text=f"‚ùå Êâæ‰∏çÂà∞„Äå{keyword}„ÄçÁöÑÂ∞çÊáâ BOSS"))
            return

        # ‚úÖ alias listÔºàÂè™È°ØÁ§∫Êú¨Áæ§‰ΩøÁî®ÈÅéÁöÑ BOSSÔºâ
        if subcommand == "list":
            group_id = event.source.group_id if event.source.type == "group" else "single"
            if group_id == "single":
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="‚ö†Ô∏è Ê≠§ÂäüËÉΩÂÉÖÈôêÁæ§ÁµÑ‰ΩøÁî®"))
                return

            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("""
                SELECT DISTINCT a.keyword, b.display_name
                FROM boss_aliases a
                JOIN boss_list b ON a.boss_id = b.id
                JOIN boss_tasks t ON b.id = t.boss_id
                WHERE t.group_id = %s
                ORDER BY b.display_name
            """, (group_id,))
            rows = cursor.fetchall()
            cursor.close()
            conn.close()

            if not rows:
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="üì≠ Êú¨Áæ§ÁµÑÂ∞öÊú™‰ΩøÁî®ÈÅé‰ªª‰ΩïÂà•Âêç„ÄÇ"))
                return

            # Âª∫Á´ã Flex Message Âç°ÁâáÂÖßÂÆπ
            alias_contents = [
                {
                    "type": "box",
                    "layout": "horizontal",
                    "contents": [
                        {"type": "text", "text": k, "size": "sm", "flex": 2, "weight": "bold"},
                        {"type": "text", "text": "‚Üí", "size": "sm", "flex": 1},
                        {"type": "text", "text": n, "size": "sm", "flex": 5}
                    ]
                } for k, n in rows
            ]

            bubble = {
                "type": "bubble",
                "body": {
                    "type": "box",
                    "layout": "vertical",
                    "contents": [
                        {"type": "text", "text": "üìò Êú¨Áæ§ÁµÑÂà•ÂêçÊ∏ÖÂñÆ", "weight": "bold", "size": "md", "margin": "md"},
                        {"type": "separator", "margin": "md"},
                        *alias_contents
                    ]
                }
            }

            line_bot_api.reply_message(event.reply_token, FlexSendMessage(alt_text="Êú¨Áæ§Âà•ÂêçÊ∏ÖÂñÆ", contents=bubble))
            return

        # alias Êñ∞Â¢û keyword ‚Üí display_name
        if len(parts) >= 3:
            keyword = parts[1].lower()
            target_name = parts[2]
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute("SELECT id FROM boss_list WHERE display_name = %s", (target_name,))
            row = cursor.fetchone()
            if row:
                boss_id = row[0]
                cursor.execute(
                    "INSERT INTO boss_aliases (boss_id, keyword) VALUES (%s, %s) ON CONFLICT DO NOTHING",
                    (boss_id, keyword)
                )
                conn.commit()
                reply_text = f"‚úÖ Â∑≤Â∞á„Äå{keyword}„ÄçË®≠ÂÆöÁÇ∫„Äå{target_name}„ÄçÁöÑÂà•ÂêçÔºÅ"
            else:
                reply_text = f"‚ùå Êâæ‰∏çÂà∞ÂêçÁ®±ÁÇ∫„Äå{target_name}„ÄçÁöÑ BOSS„ÄÇ"
            cursor.close()
            conn.close()
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text))
            return


# Ëá™ÂãïÊé®Êí≠ÔºöÈáçÁîüÊôÇÈñìÂÄíÊï∏ÂÖ©ÂàÜÈêòÊèêÈÜí
def reminder_job():
    try:
        tz = pytz.timezone("Asia/Taipei")
        now = datetime.now(tz)
        soon = now + timedelta(minutes=2)
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT b.display_name, t.group_id, t.respawn_time
            FROM boss_tasks t
            JOIN boss_list b ON b.id = t.boss_id
            WHERE t.respawn_time BETWEEN %s AND %s
        """, (now, soon))
        results = cursor.fetchall()
        for name, group_id, respawn in results:
            if not group_id or not group_id.startswith("C"):
                print(f"‚ö†Ô∏è ÁÑ°Êïà group_idÔºö{group_id}ÔºåË∑≥ÈÅé")
                continue
            try:
                msg = f"*{name}* Âç≥Â∞áÂá∫Áèæ"
                line_bot_api.push_message(group_id, TextSendMessage(text=msg))
            except Exception as e:
                print(f"‚ùå ÊèêÈÜíÂ§±ÊïóÔºö{e}")
        cursor.close()
        conn.close()
    except Exception as e:
        print("‚ùå ÊéíÁ®ãÊèêÈÜíÈåØË™§Ôºö", e)


@app.route("/debug-respawn", methods=["GET"])
def debug_respawn_route():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("""
        SELECT 
            b.display_name AS boss_name,
            t.kill_time,
            t.respawn_time,
            b.respawn_hours,
            EXTRACT(EPOCH FROM (t.respawn_time - t.kill_time)) / 3600 AS actual_hours,
            (EXTRACT(EPOCH FROM (t.respawn_time - t.kill_time)) / 3600) - b.respawn_hours AS hour_difference
        FROM boss_tasks t
        JOIN boss_list b ON t.boss_id = b.id
        ORDER BY t.respawn_time DESC
        LIMIT 20
    """)
    rows = cursor.fetchall()
    cursor.close()
    conn.close()

    output = "<h2>ÈáçÁîüÊôÇÈñìË™§Â∑ÆÊ™¢Êü•</h2><ul>"
    for row in rows:
        boss, kill, respawn, expected, actual, diff = row
        output += f"<li><b>{boss}</b>ÔºöÈ†êÊúü {expected} Â∞èÊôÇÔºåÂØ¶Èöõ {actual:.2f} Â∞èÊôÇÔºåË™§Â∑Æ {diff:.2f} Â∞èÊôÇ</li>"
    output += "</ul>"
    return output


if __name__ == "__main__":
    scheduler = BackgroundScheduler()
    scheduler.add_job(reminder_job, "interval", minutes=1)
    scheduler.start()
    app.run(port=5000)
    